from burp import IBurpExtender
from burp import IScannerCheck
from burp import IScanIssue
from java.io import PrintWriter
from array import array
import re
import urllib

#################################################
# INFO Work in progress!
#################################################

NAME = "Suspicious Parameter?"

class BurpExtender(IBurpExtender):

    def registerExtenderCallbacks(self, input_callbacks):
        global callbacks, helpers, perr, pout

        # keep a reference to our callbacks object
        callbacks = input_callbacks

        # obtain an extension helpers object
        helpers = callbacks.getHelpers()

        # set our extension name
        callbacks.setExtensionName(NAME)

        # Create a check object
        check = MyCheck()

        # Set the printers
        pout = PrintWriter(callbacks.getStdout(), True)
        perr = PrintWriter(callbacks.getStderr(), True)

        # Register the check object
        callbacks.registerScannerCheck(check)



class AffectedParam:

    def __init__(self, name, value):
        self.name = name
        self.value = value
        self.sql = False
        self.file_include = False
        self.path = False
        self.url = False

    def set_sql(self):
        self.sql = True

    def set_url(self):
        self.url = True

    def set_file_include(self):
        self.file_include = True

    def set_path(self):
        self.path = True

    def has_problems(self):
        return self.path or self.file_include or self.sql or self.url

    def __str__(self):
        s = ""

        s += "{} = {}".format(self.name, self.value)
        s += "\nPotential problems: "

        if self.sql:
            s += "- sql"
        if self.file_include:
            s += "- file inclusion"
        if self.path:
            s += "- path"
        if self.url:
            s += "- url"

        return s


class MyCheck(IScannerCheck):

    def __init__(self):
        self.paths = "(\/\S+)+"
        self.fileext = "\.[a-zA-Z]{1,5}"
        self.sqlkeywords = {"select", "from", "where", "union", "like", "show", "insert", "limit", "order by", "asc", "desc"}
        self.url = "(http|https)://[a-zA-Z0-9./?=_-]*"


    def debugShowReqResp(self, request, response):
        # Log Output
        pout.println("From the passive scan")

        if request:
            pout.println("== Request ==")
            pout.println(helpers.bytesToString(request))

        if response:
            pout.println("== Response ==")
            pout.println(helpers.bytesToString(response))


    def doPassiveScan(self, baseRequestResponse):
        # Get all nessecary infos from burp
        request       = baseRequestResponse.getRequest()
        response      = baseRequestResponse.getResponse()
        url           = helpers.analyzeRequest(baseRequestResponse).getUrl()
        http_messages = [callbacks.applyMarkers(baseRequestResponse, None, None)]

        affected_params = []
        issues          = []

        # Log output
        #self.debugShowReqResp(request, response)

        params = helpers.analyzeRequest(request).getParameters()

        # Inspect parameters of the request
        if len(params) > 0:
            #pout.println(params)

            for p in params:
                name = p.getName()
                value = p.getValue()

                # Decode the value (two time in the case of double encoding)
                value = urllib.unquote(urllib.unquote(value))

                #pout.println("Name: {}   Value: {}".format(name, value))

                aff_param = AffectedParam(name, value)

                # Contains it sql statements?
                for sql_kw in self.sqlkeywords:
                    if sql_kw in value:
                        aff_param.set_sql()
                        break

                # Matches it the file extension pattern?
                if re.search(self.fileext, value):
                    aff_param.set_file_include()

                # Does a parameter contain a path?
                if re.search(self.paths, value):
                    aff_param.set_path()

                # Matches the parameter the URL pattern?
                if re.search(self.url, value):
                    aff_param.set_url()

                # Check if the parameter should be appended
                if aff_param.has_problems():
                    affected_params.append(aff_param)


            # Reporting of all affected problems
            for p in affected_params:
                detail = str(p)
                severity = "Decide yourself!"

                issue = CustomScanIssue(baseRequestResponse.getHttpService(),
                                        url,
                                        http_messages,
                                        NAME,
                                        detail,
                                        severity)
                issues.append(issue)


        # The reference to "issues" will fail, if you don't implement it
        return [issues]


class CustomScanIssue (IScanIssue):

    def __init__(self, httpService, url, httpMessages, name, detail, severity):
        self._httpService  = httpService
        self._url          = url
        self._httpMessages = httpMessages
        self._name         = name
        self._detail       = detail
        self._severity     = severity

    def getUrl(self):
        return self._url

    def getIssueName(self):
        return self._name

    def getIssueType(self):
        return 0

    def getSeverity(self):
        return self._severity

    def getConfidence(self):
        return "Certain"

    def getIssueBackground(self):
        pass

    def getRemediationBackground(self):
        pass

    def getIssueDetail(self):
        return self._detail

    def getRemediationDetail(self):
        pass

    def getHttpMessages(self):
        return self._httpMessages

    def getHttpService(self):
        return self._httpService
