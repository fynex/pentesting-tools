package main

import (
	"flag"
	"fmt"
	"github.com/Ullaakut/nmap"
	. "github.com/logrusorgru/aurora"
	"io/ioutil"
	"os"
	"sort"
	"strings"
)

var VERBOSE = flag.Bool("v", false, "Shows verbose information")
var SILENT = flag.Bool("silent", false, "Surpresses error messages. Useful for generating lists on erroneous XML files")
var HOST_LONG_LINER_SEP = ""

func LogErr(message string, err error) {
	if !*SILENT {
		if err != nil {
			fmt.Println(message)
			fmt.Println(err)
		}
	}
}

func getScriptOutput(scripts []nmap.Script) string {
	result := ""
	for _, script := range scripts {

		//result += fmt.Sprintf("Name: %s\nOutput: %s\n", script.ID, script.Output)
		result += fmt.Sprintf("Name: %s\nOutput: %s\n", script.ID, script.Output)
		//OtherStuff: %s ---- %s, script.Elements, script.Tables
	}

	return result
}

func verbosePortInfo(port nmap.Port) {
	if *VERBOSE {
		versionInfo := ""
		extraInfo := ""
		productInfo := ""
		reasonInfo := ""

		if port.State.Reason != "" {
			reasonInfo = fmt.Sprintf("[>] Reason: %s\n", port.State.Reason)
		}
		if port.Service.Product != "" {
			productInfo = fmt.Sprintf("[>] Product: %s\n", port.Service.Product)
		}

		if port.Service.Version != "" {
			versionInfo = fmt.Sprintf("[>] Version: %s\n", port.Service.Version)
		}

		if port.Service.ExtraInfo != "" {
			extraInfo = fmt.Sprintf("[>] Extra Info: %s\n", port.Service.ExtraInfo)
		}

		fmt.Printf("%s%s%s%s\n[>] Script Info: %s\n", reasonInfo, productInfo, versionInfo, extraInfo, getScriptOutput(port.Scripts))
	}
}

func printHostLine(host nmap.Host, hostname string) {
	if *VERBOSE {
		fmt.Println("=========================")
	}

	fmt.Printf("%s Host %q (%s):\n", Green("[*]"), host.Addresses[0], hostname)
}

func printPort(port nmap.Port) {
	fmt.Printf(" [%s] %d %s %s\n", port.Protocol, port.ID, port.State, port.Service.Name)
}

func showAll(hosts map[string][]nmap.Host, oneLine bool, longLiner bool, filterNoResponse bool) {
	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			if oneLine {
				for _, port := range host.Ports {
					fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
				}
			} else if longLiner {
				for _, host := range host.Addresses {
					fmt.Printf("%s%s", host, HOST_LONG_LINER_SEP)
				}
			} else {
				//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
				if shouldPrintHostLine {
					printHostLine(host, hostname)
					shouldPrintHostLine = false
				}

				for _, port := range host.Ports {
					//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					printPort(port)

					verbosePortInfo(port)
				}
			}
		}
	}
}

func filterVersionInformation(hosts map[string][]nmap.Host) {
	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			if shouldPrintHostLine {
				printHostLine(host, hostname)
				shouldPrintHostLine = false
			}

			for _, port := range host.Ports {
				if port.Service.Version != "" {
					product := fmt.Sprintf("\tProduct: %s", port.Service.Product)
					versionInfo := fmt.Sprintf("\tVersion: %s\n", port.Service.Version)

					//fmt.Printf("\tPort   : %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
					printPort(port)
					fmt.Println(product)
					fmt.Println(versionInfo)

					verbosePortInfo(port)
				}
			}

		}
	}
}

//func filterProductsByHost(result *nmap.Run) {
//	for _, host := range result.Hosts {
//		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
//			continue
//		}
//
//		hostname := ""
//		if len(host.Hostnames) > 0 {
//			hostname = host.Hostnames[0].String()
//		}
//
//		printHostLine(host, hostname)
//
//		for _, port := range host.Ports {
//			if port.Service.Product != "" {
//				productAndVersion := port.Service.Product + " " + port.Service.Version
//
//				//fmt.Printf("\tPort   : %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
//				printPort(port)
//				fmt.Println("\t" + productAndVersion)
//
//				verbosePortInfo(port)
//			}
//		}
//
//	}
//}

func filterByServiceName(hosts map[string][]nmap.Host, serviceName string, oneLine bool, longLiner bool, filterNoResponse bool) {

	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			hostPrinted := false
			if oneLine {
				for _, port := range host.Ports {
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					if serviceName == port.Service.Name {
						fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
					}
				}
			} else if longLiner {
				for _, port := range host.Ports {
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					if serviceName == port.Service.Name {
						for _, addr := range host.Addresses {
							fmt.Printf("%s%s", addr, HOST_LONG_LINER_SEP)
						}
					}
				}
			} else {

				for _, port := range host.Ports {
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					//fmt.Println("TEST", host.Ports)
					if serviceName == port.Service.Name {
						if !hostPrinted {
							//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
							//printHostLine(host, hostname)

							if shouldPrintHostLine {
								printHostLine(host, hostname)
								shouldPrintHostLine = false
							}

							hostPrinted = true
						}
						//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
						printPort(port)

						verbosePortInfo(port)

					}
				}
			}
		}
	}
}

func filterByPort(hosts map[string][]nmap.Host, portNum int, oneLine bool, longLiner bool, filterNoResponse bool) {

	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			hostPrinted := false
			if oneLine {
				for _, port := range host.Ports {
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					if portNum == int(port.ID) {
						fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
					}
				}
			} else if longLiner {
				for _, port := range host.Ports {
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					if portNum == int(port.ID) {
						for _, addr := range host.Addresses {
							fmt.Printf("%s%s", addr, HOST_LONG_LINER_SEP)
						}
					}
				}

			} else {
				//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)

				for _, port := range host.Ports {
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					if portNum == int(port.ID) {
						if !hostPrinted {
							//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
							//printHostLine(host, hostname)

							if shouldPrintHostLine {
								printHostLine(host, hostname)
								shouldPrintHostLine = false
							}

							hostPrinted = true
						}
						//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
						printPort(port)

						verbosePortInfo(port)
					}
				}
			}
		}
	}
}

func nmapAddressSliceToStringStlice(addresses []nmap.Address) []string {
	strs := []string{}

	for _, address := range addresses {
		strs = append(strs, address.String())
	}

	return strs
}

func listAllProducts(hosts map[string][]nmap.Host) map[string][]string {
	uniqueProducts := map[string][]string{}

	for _, hostList := range hosts {
		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			for _, port := range host.Ports {
				if port.Service.Product != "" {
					productAndVersion := port.Service.Product + " " + port.Service.Version

					if _, ok := uniqueProducts[productAndVersion]; !ok {
						addressesStrings := nmapAddressSliceToStringStlice(host.Addresses)
						concatedHosts := fmt.Sprintf("%s:%d", strings.Join(addressesStrings, ", "), port.ID)

						if _, ok := uniqueProducts[productAndVersion]; ok {
							uniqueProducts[productAndVersion] = append(uniqueProducts[productAndVersion], concatedHosts)
						} else {
							uniqueProducts[productAndVersion] = []string{concatedHosts}
						}
					}
				}
			}

		}
	}

	return uniqueProducts
}

func listAllServices(hosts map[string][]nmap.Host, filterNoResponse bool) map[string]bool {
	uniqueServices := map[string]bool{}

	for _, hostList := range hosts {
		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			for _, port := range host.Ports {
				if filterNoResponse && !hasPortResponded(port.State) {
					continue
				}

				service := fmt.Sprintf("%s", port.Service.Name)

				if _, ok := uniqueServices[service]; !ok {
					uniqueServices[service] = true
				}
			}
		}
	}

	//for key, _ := range uniqueServices {
	//	fmt.Println(key)
	//}
	return uniqueServices
}

func printUniqueSortedKeysFromMap(all map[string]bool) {
	mySlice := []string{}

	for k, _ := range all {
		mySlice = append(mySlice, k)
	}

	sort.Strings(mySlice)

	for _, key := range mySlice {
		fmt.Println(key)
	}

}

func printUniqueSortedKeysFromMapWithStringSlice(all map[string][]string) {
	mySlice := []string{}

	for k, _ := range all {
		mySlice = append(mySlice, k)
	}

	sort.Strings(mySlice)

	for _, key := range mySlice {
		fmt.Println(key)
		if *VERBOSE {
			for _, host := range all[key] {
				fmt.Println("- " + host)
			}
		}
	}

}

func hasPortResponded(state nmap.State) bool {
	return state.Reason != "no-response"
}

//func filterByAllInfoSubStr(result *nmap.Run, substring string, oneLine bool) {
//	for _, host := range result.Hosts {
//		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
//			continue
//		}
//
//		hostname := ""
//		if len(host.Hostnames) > 0 {
//			hostname = host.Hostnames[0].String()
//		}
//
//		hostPrinted := false
//		if oneLine {
//			for _, port := range host.Ports {
//				if serviceName == port.Service.Name {
//					fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
//				}
//			}
//		} else {
//
//			for _, port := range host.Ports {
//				if serviceName == port.Service.Name {
//					if !hostPrinted {
//						//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
//						printHostLine(host, hostname)
//
//						hostPrinted = true
//					}
//					fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
//
//					verbosePortInfo(port)
//
//				}
//			}
//		}
//	}
//}

func showHost(hosts map[string][]nmap.Host, ip string, filterNoResponse bool) {
	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			if host.Addresses[0].Addr == ip {

				//printHostLine(host, hostname)

				if shouldPrintHostLine {
					printHostLine(host, hostname)
					shouldPrintHostLine = false
				}

				for _, port := range host.Ports {
					if filterNoResponse && !hasPortResponded(port.State) {
						continue
					}

					//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
					printPort(port)

					verbosePortInfo(port)
				}

				break
			}
		}
	}
}

func joinHostData(scans []*nmap.Run) map[string][]nmap.Host {
	resHosts := map[string][]nmap.Host{}

	for _, scan := range scans {
		for _, host := range scan.Hosts {
			for _, address := range host.Addresses {
				addrStr := address.String()

				if _, ok := resHosts[addrStr]; ok {
					resHosts[addrStr] = append(resHosts[addrStr], host)
				} else {
					resHosts[addrStr] = []nmap.Host{host}
				}
			}
		}
	}

	return resHosts
}

func main() {
	serviceName := flag.String("s", "", "Filters by service name")
	oneLiner := flag.Bool("1", false, "Prints out 'IP PORT' line by line")
	longLiner := flag.Bool("host-line", false, "Prints out 'IP', 'IP' etc. in one line")
	longLinerSep := flag.String("long-liner-sep", ", ", "Sets the separator for the -2 option")
	portNum := flag.Int("p", -1, "Sets the port to filter for")
	listServices := flag.Bool("list-services", false, "Lists all determined services")
	filterVersionInfo := flag.Bool("filter-version-info", false, "Lists all port on which nmap was able to determine the version")
	listProducts := flag.Bool("list-products", false, "List all used products with verison information")
	ip := flag.String("i", "", "Shows detailed information about a specific IP")
	filterNoResponse := flag.Bool("n", false, "Filters ports which did not respond (state == 'no-response')")

	flag.Parse()

	HOST_LONG_LINER_SEP = *longLinerSep
	fileNames := flag.Args()

	allServices := map[string]bool{}
	allProducts := map[string][]string{}
	nmapScans := []*nmap.Run{}

	for _, fileName := range fileNames {
		dat, err := ioutil.ReadFile(fileName)

		nmaprunXMLEnding := string(dat[len(dat)-11:])

		if !strings.Contains(nmaprunXMLEnding, "</nmaprun>") {
			fmt.Println(nmaprunXMLEnding)
			fmt.Println("Scan XML of", fileName, "is not complete. Try to add a </nmaprun> ending tag")
			dat = append(dat, []byte("</nmaprun>")[:]...)
		}

		if err != nil {
			fmt.Println("[!] Unable to read file", fileName)
			fmt.Println(err)

			os.Exit(1)
		}

		result, err := nmap.Parse(dat)
		LogErr("[!] Error in XML file: "+fileName, err)
		if err == nil {
			nmapScans = append(nmapScans, result)
		}
	}

	hosts := joinHostData(nmapScans)

	////fmt.Println("[*] Parsed File:", fileName)

	//dat, err := ioutil.ReadFile(fileName)

	//if err != nil {
	//	fmt.Println("[!] Unable to read file", fileName)
	//	fmt.Println(err)

	//	os.Exit(1)
	//}

	//result, err := nmap.Parse(dat)
	//LogErr("[!] Error in XML file: "+fileName, err)

	if *serviceName != "" {
		filterByServiceName(hosts, *serviceName, *oneLiner, *longLiner, *filterNoResponse)
	} else if *portNum != -1 {
		filterByPort(hosts, *portNum, *oneLiner, *longLiner, *filterNoResponse)
	} else if *listServices {
		for k, v := range listAllServices(hosts, *filterNoResponse) {
			allServices[k] = v
		}
	} else if *filterVersionInfo {
		filterVersionInformation(hosts)
	} else if *listProducts {
		for k, v := range listAllProducts(hosts) {
			allProducts[k] = v
		}
	} else if *ip != "" {
		showHost(hosts, *ip, *filterNoResponse)
	} else {
		showAll(hosts, *oneLiner, *longLiner, *filterNoResponse)
	}

	//if !*oneLiner {
	//	fmt.Println()
	//}

	if *listProducts {
		printUniqueSortedKeysFromMapWithStringSlice(allProducts)
		//printUniqueSortedKeysFromMap(allProducts)
	}

	if *listServices {
		printUniqueSortedKeysFromMap(allServices)

		//serviceSlice := []string{}

		//for k, _ := range allServices {
		//	serviceSlice = append(serviceSlice, k)
		//}

		//sort.Strings(serviceSlice)

		//for _, service := range serviceSlice {
		//	fmt.Println(service)
		//}
	}
}
