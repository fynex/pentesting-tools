package main

import (
	"flag"
	"fmt"
	"github.com/Ullaakut/nmap"
	//. "github.com/logrusorgru/aurora"
	"io/ioutil"
	"os"
	"sort"
	"strings"
)

var (
	VERBOSE             = flag.Bool("v", false, "Shows verbose information")
	SILENT              = flag.Bool("silent", false, "Surpresses error messages. Useful for generating lists on erroneous XML files")
	HOST_LONG_LINER_SEP = ""
	LONG_LINER          = false
	ONE_LINER           = false
	WITH_PORTS          = false
	HOST_PORT_SEP       = ":"
)

func ResolveTLSTunnel(port nmap.Port) string {
	serviceName := port.Service.Name
	suffixSServices := []string{"http", "imap", "pop3"}

	if port.Service.Tunnel == "ssl" {
		for _, srv := range suffixSServices {
			if serviceName == srv {
				return serviceName + "s"
			}
		}

		return serviceName + " (tls)"
	}

	return serviceName
}

func LogErr(message string, err error) {
	if !*SILENT {
		if err != nil {
			fmt.Println(message)
			fmt.Println(err)
		}
	}
}

func getScriptOutput(scripts []nmap.Script) string {
	result := ""
	for _, script := range scripts {

		//result += fmt.Sprintf("Name: %s\nOutput: %s\n", script.ID, script.Output)
		result += fmt.Sprintf("Name: %s\nOutput: %s\n", script.ID, script.Output)
		//OtherStuff: %s ---- %s, script.Elements, script.Tables
	}

	return result
}

func verbosePortInfo(port nmap.Port) {
	if *VERBOSE {
		versionInfo := ""
		extraInfo := ""
		productInfo := ""
		reasonInfo := ""

		if port.State.Reason != "" {
			reasonInfo = fmt.Sprintf("[>] Reason: %s\n", port.State.Reason)
		}
		if port.Service.Product != "" {
			productInfo = fmt.Sprintf("[>] Product: %s\n", port.Service.Product)
		}

		if port.Service.Version != "" {
			versionInfo = fmt.Sprintf("[>] Version: %s\n", port.Service.Version)
		}

		if port.Service.ExtraInfo != "" {
			extraInfo = fmt.Sprintf("[>] Extra Info: %s\n", port.Service.ExtraInfo)
		}

		fmt.Printf("%s%s%s%s\n[>] Script Info: %s\n", reasonInfo, productInfo, versionInfo, extraInfo, getScriptOutput(port.Scripts))
	}
}

func printHostLine(host nmap.Host, hostname string) {
	if *VERBOSE {
		fmt.Println("=========================")
	}

	//fmt.Printf("%s Host %q (%s):\n", Green("[*]"), host.Addresses[0], hostname)
	fmt.Printf("%s Host %q (%s):\n", "[*]", host.Addresses[0], hostname)
}

func filterNoResponsePorts(hostList map[string][]nmap.Host) map[string][]nmap.Host {
	return filterPortsByStatus(hostList, "no-response")
	//hosts := map[string][]nmap.Host{}

	//for ip, hostsublist := range hostList {
	//	for _, host := range hostsublist {
	//		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
	//			continue
	//		}

	//		newPorts := []nmap.Port{}

	//		for _, port := range host.Ports {
	//			if !hasPortResponded(port.State) {
	//				continue
	//			}

	//			newPorts = append(newPorts, port)
	//		}

	//		host.Ports = newPorts
	//		hosts[ip] = append(hosts[ip], host)
	//	}
	//}

	//return hosts
}

func filterClosedPorts(hostList map[string][]nmap.Host) map[string][]nmap.Host {
	return filterPortsByStatus(hostList, "closed")
	//hosts := map[string][]nmap.Host{}

	//for ip, hostsublist := range hostList {
	//	for _, host := range hostsublist {
	//		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
	//			continue
	//		}

	//		newPorts := []nmap.Port{}

	//		for _, port := range host.Ports {
	//			if isPortClosed(port.State) {
	//				continue
	//			}

	//			newPorts = append(newPorts, port)
	//		}

	//		host.Ports = newPorts
	//		hosts[ip] = append(hosts[ip], host)
	//	}
	//}

	//return hosts
}

func filterFilteredPorts(hostList map[string][]nmap.Host) map[string][]nmap.Host {
	return filterPortsByStatus(hostList, "filtered")
}

func filterPortsByStatus(hostList map[string][]nmap.Host, status string) map[string][]nmap.Host {
	hosts := map[string][]nmap.Host{}

	for ip, hostsublist := range hostList {
		for _, host := range hostsublist {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			newPorts := []nmap.Port{}

			for _, port := range host.Ports {
				if port.State.State == status {
					continue
				}

				newPorts = append(newPorts, port)
			}

			host.Ports = newPorts
			hosts[ip] = append(hosts[ip], host)
		}
	}

	return hosts
}

// func ParseConf(port nmap.Port) string {
// 	if port.Service.Configuration <= 3 {
// 		return " ?"
// 	}
//
// 	return ""
// }

func printPort(port nmap.Port) {
	fmt.Printf(" [%s] %d %s %s%s\n", port.Protocol, port.ID, port.State, ResolveTLSTunnel(port), "") //ParseConf(port))
}

//func printCSV(hosts map[string][]nmap.Host, filterNoResponse bool) {
func printCSV(hosts map[string][]nmap.Host) {

	portsCSVStrings := []string{}

	for _, hostList := range hosts {

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
			//if shouldPrintHostLine {
			//	printHostLine(host, hostname)
			//	shouldPrintHostLine = false
			//}

			for _, port := range host.Ports {
				//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
				//if filterNoResponse && !hasPortResponded(port.State) {
				//	continue
				//}

				//verbosePortInfo(port)
				ps := fmt.Sprintf(`"%s";"%s";"%d";"%s";"%s";"%s"`, host.Addresses[0], hostname, port.ID, port.Protocol, ResolveTLSTunnel(port), port.State)
				portsCSVStrings = append(portsCSVStrings, ps)
			}
		}
	}

	sort.Strings(portsCSVStrings)

	fmt.Println(`"IP";"HOSTNAME";"PORT";"PROTOCOL";"SERVICE";"STATE"`)
	for _, p := range portsCSVStrings {
		fmt.Println(p)
	}
}

//func showAll(hosts map[string][]nmap.Host, oneLine bool, longLiner bool, filterNoResponse bool) {
func showAll(hosts map[string][]nmap.Host, oneLine bool, longLiner bool) {
	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			if oneLine {
				for _, port := range host.Ports {
					//fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
					PrintOneLiner(host, port)
				}
			} else if longLiner {
				for _, host := range host.Addresses {
					if WITH_PORTS {
						fmt.Printf("%s%s%d%s", host, HOST_LONG_LINER_SEP)
					} else {
						fmt.Printf("%s%s", host, HOST_LONG_LINER_SEP)
					}
				}
			} else {
				//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
				if shouldPrintHostLine {
					printHostLine(host, hostname)
					shouldPrintHostLine = false
				}

				for _, port := range host.Ports {
					//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					printPort(port)

					verbosePortInfo(port)
				}
			}
		}
	}
}

//func showHost(hosts map[string][]nmap.Host, ip string, filterNoResponse bool) {
func showHost(hosts map[string][]nmap.Host, ip string) {
	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			if host.Addresses[0].Addr == ip {

				//printHostLine(host, hostname)

				if shouldPrintHostLine {
					printHostLine(host, hostname)
					shouldPrintHostLine = false
				}

				for _, port := range host.Ports {
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
					printPort(port)

					verbosePortInfo(port)
				}

				break
			}
		}
	}
}

//func listHosts(hosts map[string][]nmap.Host, filterNoResponse bool) {
//	for _, hostList := range hosts {
//		shouldPrintHostLine := true
//
//		for _, host := range hostList {
//			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
//				continue
//			}
//
//			hostname := ""
//			if len(host.Hostnames) > 0 {
//				hostname = host.Hostnames[0].String()
//			}
//
//			//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
//			if shouldPrintHostLine {
//				printHostLine(host, hostname)
//				shouldPrintHostLine = false
//			}
//
//			for _, port := range host.Ports {
//				//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
//				if filterNoResponse && !hasPortResponded(port.State) {
//					continue
//				}
//
//				printPort(port)
//
//				verbosePortInfo(port)
//			}
//		}
//	}
//}

func filterVersionInformation(hosts map[string][]nmap.Host) {
	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			if shouldPrintHostLine {
				printHostLine(host, hostname)
				shouldPrintHostLine = false
			}

			for _, port := range host.Ports {
				if port.Service.Version != "" {
					product := fmt.Sprintf("\tProduct: %s", port.Service.Product)
					versionInfo := fmt.Sprintf("\tVersion: %s\n", port.Service.Version)

					//fmt.Printf("\tPort   : %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
					printPort(port)
					fmt.Println(product)
					fmt.Println(versionInfo)

					verbosePortInfo(port)
				}
			}

		}
	}
}

//func filterProductsByHost(result *nmap.Run) {
//	for _, host := range result.Hosts {
//		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
//			continue
//		}
//
//		hostname := ""
//		if len(host.Hostnames) > 0 {
//			hostname = host.Hostnames[0].String()
//		}
//
//		printHostLine(host, hostname)
//
//		for _, port := range host.Ports {
//			if port.Service.Product != "" {
//				productAndVersion := port.Service.Product + " " + port.Service.Version
//
//				//fmt.Printf("\tPort   : %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
//				printPort(port)
//				fmt.Println("\t" + productAndVersion)
//
//				verbosePortInfo(port)
//			}
//		}
//
//	}
//}

func PrintOneLiner(host nmap.Host, port nmap.Port) {
	if WITH_PORTS {
		fmt.Printf("%s%s%d\n", host.Addresses[0], HOST_PORT_SEP, port.ID)
	} else {
		fmt.Printf("%s\n", host.Addresses[0])
	}
}

//func filterByServiceName(hosts map[string][]nmap.Host, serviceName string, oneLine bool, longLiner bool, filterNoResponse bool) {
func filterByServiceName(hosts map[string][]nmap.Host, serviceName string, oneLine bool, longLiner bool) {

	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			hostPrinted := false
			if oneLine {
				for _, port := range host.Ports {
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					if serviceName == port.Service.Name {
						//fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
						PrintOneLiner(host, port)
					}
				}
			} else if longLiner {
				for _, port := range host.Ports {
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					if serviceName == port.Service.Name {
						for _, addr := range host.Addresses {
							//fmt.Printf("%s%s", addr, HOST_LONG_LINER_SEP)
							if WITH_PORTS {
								fmt.Printf("%s%s%d%s", addr, HOST_PORT_SEP, port.ID, HOST_LONG_LINER_SEP)
							} else {
								fmt.Printf("%s%s", addr, HOST_LONG_LINER_SEP)
							}
						}
					}
				}
			} else {

				for _, port := range host.Ports {
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					//fmt.Println("TEST", host.Ports)
					if serviceName == port.Service.Name {
						if !hostPrinted {
							//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
							//printHostLine(host, hostname)

							if shouldPrintHostLine {
								printHostLine(host, hostname)
								shouldPrintHostLine = false
							}

							hostPrinted = true
						}
						//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
						printPort(port)

						verbosePortInfo(port)

					}
				}
			}
		}
	}
}

//func filterByPort(hosts map[string][]nmap.Host, portNum int, oneLine bool, longLiner bool, filterNoResponse bool) {
func filterByPort(hosts map[string][]nmap.Host, portNum int, oneLine bool, longLiner bool) {

	for _, hostList := range hosts {
		shouldPrintHostLine := true

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			hostname := ""
			if len(host.Hostnames) > 0 {
				hostname = host.Hostnames[0].String()
			}

			hostPrinted := false
			if oneLine {
				for _, port := range host.Ports {
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					if portNum == int(port.ID) {
						//fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
						PrintOneLiner(host, port)
					}
				}
			} else if longLiner {
				for _, port := range host.Ports {
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					if portNum == int(port.ID) {
						for _, addr := range host.Addresses {
							//fmt.Printf("%s%s", addr, HOST_LONG_LINER_SEP)

							if WITH_PORTS {
								fmt.Printf("%s%s%d%s", addr, HOST_LONG_LINER_SEP, port.ID)
							} else {
								fmt.Printf("%s%s", addr, HOST_LONG_LINER_SEP)
							}
						}
					}
				}

			} else {
				//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)

				for _, port := range host.Ports {
					//if filterNoResponse && !hasPortResponded(port.State) {
					//	continue
					//}

					if portNum == int(port.ID) {
						if !hostPrinted {
							//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
							//printHostLine(host, hostname)

							if shouldPrintHostLine {
								printHostLine(host, hostname)
								shouldPrintHostLine = false
							}

							hostPrinted = true
						}
						//fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
						printPort(port)

						verbosePortInfo(port)
					}
				}
			}
		}
	}
}

func nmapAddressSliceToStringStlice(addresses []nmap.Address) []string {
	strs := []string{}

	for _, address := range addresses {
		strs = append(strs, address.String())
	}

	return strs
}

func listAllProducts(hosts map[string][]nmap.Host) map[string][]string {
	uniqueProducts := map[string][]string{}

	for _, hostList := range hosts {
		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			for _, port := range host.Ports {
				if port.Service.Product != "" {
					productAndVersion := port.Service.Product + " " + port.Service.Version

					//if _, ok := uniqueProducts[productAndVersion]; !ok {
					addressesStrings := nmapAddressSliceToStringStlice(host.Addresses)
					concatedHosts := fmt.Sprintf("%s:%d", strings.Join(addressesStrings, ", "), port.ID)

					if _, ok := uniqueProducts[productAndVersion]; ok {
						uniqueProducts[productAndVersion] = append(uniqueProducts[productAndVersion], concatedHosts)
					} else {
						uniqueProducts[productAndVersion] = []string{concatedHosts}
					}
					//}
				}
			}

		}
	}

	return uniqueProducts
}

//func listAllServices(hosts map[string][]nmap.Host, filterNoResponse bool) map[string]bool {
func listAllServices(hosts map[string][]nmap.Host) map[string]bool {
	uniqueServices := map[string]bool{}

	for _, hostList := range hosts {
		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}

			for _, port := range host.Ports {
				//if filterNoResponse && !hasPortResponded(port.State) {
				//	continue
				//}

				service := fmt.Sprintf("%s", port.Service.Name)

				if _, ok := uniqueServices[service]; !ok {
					uniqueServices[service] = true
				}
			}
		}
	}

	//for key, _ := range uniqueServices {
	//	fmt.Println(key)
	//}
	return uniqueServices
}

func printUniqueSortedKeysFromMap(all map[string]bool) {
	mySlice := []string{}

	for k, _ := range all {
		mySlice = append(mySlice, k)
	}

	sort.Strings(mySlice)

	for _, key := range mySlice {
		fmt.Println(key)
	}

}

func printUniqueSortedKeysFromMapWithStringSlice(all map[string][]string) {
	mySlice := []string{}

	for k, _ := range all {
		mySlice = append(mySlice, k)
	}

	sort.Strings(mySlice)

	for _, key := range mySlice {
		fmt.Println(key)
		if *VERBOSE {
			for _, host := range all[key] {
				fmt.Println("- " + host)
			}
		}
	}

}

func hasPortResponded(state nmap.State) bool {
	return state.Reason != "no-response"
}

func isPortClosed(state nmap.State) bool {
	return state.State == "closed"
}

//func filterByAllInfoSubStr(result *nmap.Run, substring string, oneLine bool) {
//	for _, host := range result.Hosts {
//		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
//			continue
//		}
//
//		hostname := ""
//		if len(host.Hostnames) > 0 {
//			hostname = host.Hostnames[0].String()
//		}
//
//		hostPrinted := false
//		if oneLine {
//			for _, port := range host.Ports {
//				if serviceName == port.Service.Name {
//					fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
//				}
//			}
//		} else {
//
//			for _, port := range host.Ports {
//				if serviceName == port.Service.Name {
//					if !hostPrinted {
//						//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
//						printHostLine(host, hostname)
//
//						hostPrinted = true
//					}
//					fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
//
//					verbosePortInfo(port)
//
//				}
//			}
//		}
//	}
//}

//func hostTable(hosts map[string][]nmap.Host, filterNoResponse bool) {
func hostTable(hosts map[string][]nmap.Host) {
	for _, hostList := range hosts {
		portStr := ""
		ip := ""

		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}
			ip = host.Addresses[0].Addr
			//hostname := ""
			//if len(host.Hostnames) > 0 {
			//	hostname = host.Hostnames[0].String()
			//}

			//if host.Addresses[0].Addr == ip {
			for _, port := range host.Ports {
				//if filterNoResponse && !hasPortResponded(port.State) {
				//	continue
				//}

				if port.State.State == "open" {
					portStr += fmt.Sprintf("%d/%s", port.ID, port.Protocol)
					portStr += ", "
				}
			}

		}

		if portStr != "" {
			portStr = portStr[:len(portStr)-2]
		}

		if ip != "" {
			fmt.Printf("|%s|%s|\n", ip, portStr)
		}
	}
}

//func genNmapCmd(hosts map[string][]nmap.Host, filterNoResponse bool) {
func genNmapCmd(hosts map[string][]nmap.Host) {
	for _, hostList := range hosts {
		for _, host := range hostList {
			if len(host.Ports) == 0 || len(host.Addresses) == 0 {
				continue
			}
			ip := host.Addresses[0].Addr
			//hostname := ""
			//if len(host.Hostnames) > 0 {
			//	hostname = host.Hostnames[0].String()
			//}

			//if host.Addresses[0].Addr == ip {
			portStr := ""
			for _, port := range host.Ports {
				//if filterNoResponse && !hasPortResponded(port.State) {
				//	continue
				//}

				if port.State.State == "open" {
					portStr += fmt.Sprintf("%d", port.ID)
					portStr += ","
				}
			}

			if portStr != "" {
				portStr = portStr[:len(portStr)-1]
			}

			if portStr != "" {
				//newParams := params
				//fmt.Println("params", newParams)
				//if newParams != "no-options" {
				//	newParams = " " + newParams
				//}
				fmt.Printf("nmap -sS -oA retest-%s -p %s %s\n", strings.Replace(ip, ".", "-", -1), portStr, ip)
			}
		}
	}
}

func joinHostData(scans []*nmap.Run) map[string][]nmap.Host {
	resHosts := map[string][]nmap.Host{}

	for _, scan := range scans {
		for _, host := range scan.Hosts {
			//for _, address := range host.Addresses {
			//addrStr := address.String()
			addrStr := host.Addresses[0].String()

			if _, ok := resHosts[addrStr]; ok {
				resHosts[addrStr] = append(resHosts[addrStr], host)
			} else {
				resHosts[addrStr] = []nmap.Host{host}
			}
			//}
		}
	}

	return resHosts
}

func main() {
	serviceName := flag.String("s", "", "Filters by service name")
	oneLiner := flag.Bool("1", false, "Prints out 'IP' line by line. If '--with-ports' is stated IP:PORT will be printed. The separator can be set with '--host-port-sep'")
	longLiner := flag.Bool("2", false, "Prints out 'IP', 'IP' etc. in one line")
	longLinerSep := flag.String("long-liner-sep", ", ", "Sets the separator for the -2 option")
	withPorts := flag.Bool("with-ports", false, "Prints the long and one liner with ports")
	hostPortSep := flag.String("host-port-sep", ":", "Defines the separator between host and port in the long and one liner")
	portNum := flag.Int("p", -1, "Sets the port to filter for")
	listServices := flag.Bool("list-services", false, "Lists all determined services")
	filterVersionInfo := flag.Bool("filter-version-info", false, "Lists all port on which nmap was able to determine the version")
	listProducts := flag.Bool("list-products", false, "List all used products with version information")
	hostlist := flag.Bool("host-port-table", false, "List all hosts and ports in a markdown table like |IP|PORT1,PORT2|.")
	genNmapCmdRetest := flag.String("gen-nmap-retest", "no-options", "Generates a nmap command line from xml results of the open ports e.g. to retest open connections.")
	printcsv := flag.Bool("print-csv", false, "Prints a CSV file from the read data")
	ip := flag.String("i", "", "Shows detailed information about a specific IP")
	filterNoResponse := flag.Bool("pn", false, "Filters ports which did not respond (state == 'no-response')")
	ptfFilterClosedPorts := flag.Bool("pc", false, "Filters ports which are closed (state == 'close')")
	ptfFilterFilteredPorts := flag.Bool("pf", false, "Filters ports which are closed (state == 'close')")

	flag.Parse()

	HOST_LONG_LINER_SEP = *longLinerSep
	LONG_LINER = *longLiner
	ONE_LINER = *oneLiner
	WITH_PORTS = *withPorts
	HOST_PORT_SEP = *hostPortSep

	fileNames := flag.Args()

	allServices := map[string]bool{}
	allProducts := map[string][]string{}
	nmapScans := []*nmap.Run{}

	for _, fileName := range fileNames {
		dat, err := ioutil.ReadFile(fileName)

		nmaprunXMLEnding := string(dat[len(dat)-11:])

		if !strings.Contains(nmaprunXMLEnding, "</nmaprun>") {
			fmt.Println(nmaprunXMLEnding)
			fmt.Println("Scan XML of", fileName, "is not complete. Try to add a </nmaprun> ending tag")
			dat = append(dat, []byte("</nmaprun>")[:]...)
		}

		if err != nil {
			fmt.Println("[!] Unable to read file", fileName)
			fmt.Println(err)

			os.Exit(1)
		}

		result, err := nmap.Parse(dat)
		LogErr("[!] Error in XML file: "+fileName, err)
		if err == nil {
			nmapScans = append(nmapScans, result)
		}
	}

	hosts := joinHostData(nmapScans)

	if *filterNoResponse {
		hosts = filterNoResponsePorts(hosts)
	}

	if *ptfFilterClosedPorts {
		hosts = filterClosedPorts(hosts)
	}

	if *ptfFilterFilteredPorts {
		hosts = filterFilteredPorts(hosts)
	}

	////fmt.Println("[*] Parsed File:", fileName)

	//dat, err := ioutil.ReadFile(fileName)

	//if err != nil {
	//	fmt.Println("[!] Unable to read file", fileName)
	//	fmt.Println(err)

	//	os.Exit(1)
	//}

	//result, err := nmap.Parse(dat)
	//LogErr("[!] Error in XML file: "+fileName, err)

	if *serviceName != "" {
		filterByServiceName(hosts, *serviceName, *oneLiner, *longLiner)
	} else if *portNum != -1 {
		filterByPort(hosts, *portNum, *oneLiner, *longLiner)
	} else if *listServices {
		for k, v := range listAllServices(hosts) {
			allServices[k] = v
		}
	} else if *filterVersionInfo {
		filterVersionInformation(hosts)
	} else if *listProducts {
		for k, v := range listAllProducts(hosts) {
			allProducts[k] = v
		}
	} else if *ip != "" {
		showHost(hosts, *ip)
	} else if *hostlist {
		hostTable(hosts)
	} else if *genNmapCmdRetest != "no-options" {
		genNmapCmd(hosts)
	} else if *printcsv {
		printCSV(hosts)
	} else {
		showAll(hosts, *oneLiner, *longLiner)
	}

	//if !*oneLiner {
	//	fmt.Println()
	//}

	if *listProducts {
		printUniqueSortedKeysFromMapWithStringSlice(allProducts)
		//printUniqueSortedKeysFromMap(allProducts)
	}

	if *listServices {
		printUniqueSortedKeysFromMap(allServices)

		//serviceSlice := []string{}

		//for k, _ := range allServices {
		//	serviceSlice = append(serviceSlice, k)
		//}

		//sort.Strings(serviceSlice)

		//for _, service := range serviceSlice {
		//	fmt.Println(service)
		//}
	}
}
