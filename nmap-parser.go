package main

import (
	"flag"
	"fmt"
	"github.com/Ullaakut/nmap"
	"io/ioutil"
	"os"
	"sort"
	"strings"
)

var VERBOSE = flag.Bool("v", false, "Shows verbose information")
var SILENT = flag.Bool("silent", false, "Surpresses error messages. Useful for generating lists on erroneous XML files")

func LogErr(message string, err error) {
	if !*SILENT {
		if err != nil {
			fmt.Println(message)
			fmt.Println(err)
		}
	}
}

func getScriptOutput(scripts []nmap.Script) string {
	result := ""
	for _, script := range scripts {

		//result += fmt.Sprintf("Name: %s\nOutput: %s\n", script.ID, script.Output)
		result += fmt.Sprintf("Name: %s\nOutput: %s\n", script.ID, script.Output)
		//OtherStuff: %s ---- %s, script.Elements, script.Tables
	}

	return result
}

func verbosePortInfo(port nmap.Port) {
	if *VERBOSE {
		versionInfo := ""
		extraInfo := ""
		productInfo := ""

		if port.Service.Product != "" {
			productInfo = fmt.Sprintf("[>] Product: %s\n", port.Service.Product)
		}

		if port.Service.Version != "" {
			versionInfo = fmt.Sprintf("[>] Version: %s\n", port.Service.Version)
		}

		if port.Service.ExtraInfo != "" {
			extraInfo = fmt.Sprintf("[>] Extra Info: %s\n", port.Service.ExtraInfo)
		}

		fmt.Printf("%s%s%s\n[>] Script Info: %s\n", productInfo, versionInfo, extraInfo, getScriptOutput(port.Scripts))
	}
}

func printHostLine(host nmap.Host, hostname string) {
	if *VERBOSE {
		fmt.Println("=========================")
	}

	fmt.Printf("[*] Host %q (%s):\n", host.Addresses[0], hostname)
}

func showAll(result *nmap.Run, oneLine bool) {
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		hostname := ""
		if len(host.Hostnames) > 0 {
			hostname = host.Hostnames[0].String()
		}

		if oneLine {
			for _, port := range host.Ports {
				fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
			}

		} else {
			//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
			printHostLine(host, hostname)

			for _, port := range host.Ports {
				fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)

				verbosePortInfo(port)
			}
		}
	}
}

func filterVersionInformation(result *nmap.Run) {
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		hostname := ""
		if len(host.Hostnames) > 0 {
			hostname = host.Hostnames[0].String()
		}

		printHostLine(host, hostname)

		for _, port := range host.Ports {
			if port.Service.Version != "" {
				product := fmt.Sprintf("\tProduct: %s", port.Service.Product)
				versionInfo := fmt.Sprintf("\tVersion: %s\n", port.Service.Version)

				fmt.Printf("\tPort   : %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
				fmt.Println(product)
				fmt.Println(versionInfo)

				verbosePortInfo(port)
			}
		}

	}
}

func filterProductsByHost(result *nmap.Run) {
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		hostname := ""
		if len(host.Hostnames) > 0 {
			hostname = host.Hostnames[0].String()
		}

		printHostLine(host, hostname)

		for _, port := range host.Ports {
			if port.Service.Product != "" {
				productAndVersion := port.Service.Product + " " + port.Service.Version

				fmt.Printf("\tPort   : %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
				fmt.Println("\t" + productAndVersion)

				verbosePortInfo(port)
			}
		}

	}
}

func filterByServiceName(result *nmap.Run, serviceName string, oneLine bool) {
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		hostname := ""
		if len(host.Hostnames) > 0 {
			hostname = host.Hostnames[0].String()
		}

		hostPrinted := false
		if oneLine {
			for _, port := range host.Ports {
				if serviceName == port.Service.Name {
					fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
				}
			}
		} else {

			for _, port := range host.Ports {
				if serviceName == port.Service.Name {
					if !hostPrinted {
						//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
						printHostLine(host, hostname)

						hostPrinted = true
					}
					fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)

					verbosePortInfo(port)

				}
			}
		}
	}
}

func filterByPort(result *nmap.Run, portNum int, oneLine bool) {
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		hostname := ""
		if len(host.Hostnames) > 0 {
			hostname = host.Hostnames[0].String()
		}

		hostPrinted := false
		if oneLine {
			for _, port := range host.Ports {
				if portNum == int(port.ID) {
					fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
				}
			}
		} else {
			//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)

			for _, port := range host.Ports {
				if portNum == int(port.ID) {
					if !hostPrinted {
						//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
						printHostLine(host, hostname)

						hostPrinted = true
					}
					fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)

					verbosePortInfo(port)
				}
			}
		}
	}
}

func nmapAddressSliceToStringStlice(addresses []nmap.Address) []string {
	strs := []string{}

	for _, address := range addresses {
		strs = append(strs, address.String())
	}

	return strs
}

func listAllProducts(result *nmap.Run) map[string][]string {
	uniqueProducts := map[string][]string{}

	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		for _, port := range host.Ports {
			if port.Service.Product != "" {
				productAndVersion := port.Service.Product + " " + port.Service.Version

				if _, ok := uniqueProducts[productAndVersion]; !ok {
					addressesStrings := nmapAddressSliceToStringStlice(host.Addresses)
					concatedHosts := fmt.Sprintf("%s:%d", strings.Join(addressesStrings, ", "), port.ID)

					if _, ok := uniqueProducts[productAndVersion]; ok {
						fmt.Println("Append")
						uniqueProducts[productAndVersion] = append(uniqueProducts[productAndVersion], concatedHosts)
					} else {
						fmt.Println("Create")
						uniqueProducts[productAndVersion] = []string{concatedHosts}
					}
				}
			}
		}

	}

	return uniqueProducts
}

func listAllServices(result *nmap.Run) map[string]bool {
	uniqueServices := map[string]bool{}

	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		for _, port := range host.Ports {
			service := fmt.Sprintf("%s", port.Service.Name)

			if _, ok := uniqueServices[service]; !ok {
				uniqueServices[service] = true
			}
		}
	}

	//for key, _ := range uniqueServices {
	//	fmt.Println(key)
	//}
	return uniqueServices
}

func printUniqueSortedKeysFromMap(all map[string]bool) {
	mySlice := []string{}

	for k, _ := range all {
		mySlice = append(mySlice, k)
	}

	sort.Strings(mySlice)

	for _, key := range mySlice {
		fmt.Println(key)
	}

}

func printUniqueSortedKeysFromMapWithStringSlice(all map[string][]string) {
	mySlice := []string{}

	for k, _ := range all {
		mySlice = append(mySlice, k)
	}

	sort.Strings(mySlice)

	for _, key := range mySlice {
		fmt.Println(key)
		if *VERBOSE {
			for _, host := range all[key] {
				fmt.Println("- " + host)
			}
		}
	}

}

//func filterByAllInfoSubStr(result *nmap.Run, substring string, oneLine bool) {
//	for _, host := range result.Hosts {
//		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
//			continue
//		}
//
//		hostname := ""
//		if len(host.Hostnames) > 0 {
//			hostname = host.Hostnames[0].String()
//		}
//
//		hostPrinted := false
//		if oneLine {
//			for _, port := range host.Ports {
//				if serviceName == port.Service.Name {
//					fmt.Printf("%s %d\n", host.Addresses[0], port.ID)
//				}
//			}
//		} else {
//
//			for _, port := range host.Ports {
//				if serviceName == port.Service.Name {
//					if !hostPrinted {
//						//fmt.Printf("Host %q (%s):\n", host.Addresses[0], hostname)
//						printHostLine(host, hostname)
//
//						hostPrinted = true
//					}
//					fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)
//
//					verbosePortInfo(port)
//
//				}
//			}
//		}
//	}
//}

func showHost(result *nmap.Run, ip string) {
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		hostname := ""
		if len(host.Hostnames) > 0 {
			hostname = host.Hostnames[0].String()
		}

		if host.Addresses[0].Addr == ip {

			printHostLine(host, hostname)

			for _, port := range host.Ports {
				fmt.Printf("\tPort %d/%s %s %s\n", port.ID, port.Protocol, port.State, port.Service.Name)

				verbosePortInfo(port)
			}

			break
		}
	}
}

func main() {
	serviceName := flag.String("s", "", "Filters by service name")
	oneLiner := flag.Bool("1", false, "Prints out 'IP PORT'")
	portNum := flag.Int("p", -1, "Sets the port to filter for")
	listServices := flag.Bool("list-services", false, "Lists all determined services")
	filterVersionInfo := flag.Bool("filter-version-info", false, "Lists all port on which nmap was able to determine the version")
	listProducts := flag.Bool("list-products", false, "List all used products with verison information")
	ip := flag.String("i", "", "Shows detailed information about a specific IP")

	flag.Parse()

	fileNames := flag.Args()

	allServices := map[string]bool{}
	allProducts := map[string][]string{}

	for _, fileName := range fileNames {
		//fmt.Println("[*] Parsed File:", fileName)

		dat, err := ioutil.ReadFile(fileName)

		if err != nil {
			fmt.Println("[!] Unable to read file", fileName)
			fmt.Println(err)

			os.Exit(1)
		}

		result, err := nmap.Parse(dat)
		LogErr("[!] Error in XML file: "+fileName, err)

		if *serviceName != "" {
			filterByServiceName(result, *serviceName, *oneLiner)
		} else if *portNum != -1 {
			filterByPort(result, *portNum, *oneLiner)
		} else if *listServices {
			for k, v := range listAllServices(result) {
				allServices[k] = v
			}
		} else if *filterVersionInfo {
			filterVersionInformation(result)
		} else if *listProducts {
			for k, v := range listAllProducts(result) {
				allProducts[k] = v
			}
		} else if *ip != "" {
			showHost(result, *ip)
		} else {
			showAll(result, *oneLiner)
		}

		//if !*oneLiner {
		//	fmt.Println()
		//}
	}

	if *listProducts {
		printUniqueSortedKeysFromMapWithStringSlice(allProducts)
		//printUniqueSortedKeysFromMap(allProducts)
	}

	if *listServices {
		printUniqueSortedKeysFromMap(allServices)

		//serviceSlice := []string{}

		//for k, _ := range allServices {
		//	serviceSlice = append(serviceSlice, k)
		//}

		//sort.Strings(serviceSlice)

		//for _, service := range serviceSlice {
		//	fmt.Println(service)
		//}
	}
}
